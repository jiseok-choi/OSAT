# 객체지향 프로그래밍 이란

- 객체지향이란 어떤 프로그래밍 방식, 방법론이다.

Object Oriented 프로그래밍



하나의 예시로 들어보자

> 나는 어느 한 학교의 막내 선생님이 되었다.
>
> 학교의 전교생을 데리고 학교 대청소를 해야하는 일을 맡았다.

- 학교 막내 선생님 = 개발자
- 학생들과 대청소 = 작업
- 학생들 = 컴퓨터 자원



## 절차지향으로 프로그래밍 하기

```java
int 영수_행주_깨끗함 = 100;
double 영수_윈덱스_리터 = 10.0;
우리학교._101호.창문_닦이(영수_행주_깨끗함, 영수_윈덱스_리터);

double 철권_쓰레받기_채움 = 0;
우리학교._101호.바닥_쓸기(철권_쓰레받기_채움);

int 변수_지우개_깨끗함 = 100;
우리학교._101호.칠판닦기(변수_지우개_깨끗함);

int 혁순_행주_깨끗함 = 100;
double 혁순_윈덱스_리터 = 10.0;
우리학교._101호.창문_닦기(혁순_행주_깨끗함, 혁순_윈덱스_리터);

if (영수_행주_깨끗함 <= 10)
    빨아오기(영수_행주_깨끗함);

if (철권_쓰레받기_채움 >= 0.9)
    비우기(철권_쓰레받기_채움);

if (영수_윈덱스_리터 <= 1)
    리필해오기(영수_윈덱스_리터);

if (우리학교._101호.창문_깨끗함())
    우리학교._103호.창문_닦기(영수_행주_깨끗함, 영수_윈덱스_리터);

int 돌준_행주_깨끗함 = 100;
double 돌준_윈덱스_리터 = 10.0;
우리학교._104호.창문_닦기(돌준_행주_깨끗함, 돌준_윈덱스_리터);

if (변수_지우개_깨끗함 <= 10)
    털기(변수_지우개_깨끗함);
```



- 위 코드를 다음과 같이 말로 해석해보자

>영수, 깨끗한 행주와 윈덱스를 가지고 101호 창문을 닦아
>
>철권, 쓰레받기를 들고 101호 바닥을 쓸어
>
>변수, 지우개로 101호 칠판을 닦아
>
>혁순, 행주로 102호 창문을 닦아
>
>
>
>영수 행주 깨끗하니? 안깨끗하면 빨아와
>
>철권 쓰레받기 다 채웠니? 채웠으면 비워와
>
>영수 윈덱스 다썼으면 리필해와
>
>학교 101호 창문 깨끗하니? 그럼 영수가 행주와 윈덱스 가지고 103호 창문닦으러 가렴
>
>
>
>돌준이 행주랑 윈덱스 가지고 104호 창문닦으러 가렴
>
>변수 지우개 더러워졌니 그럼 털고와



- 청소를 몇명 시키지도 않았는데 코드가 정말 많아졌다.
- 일을 시키고 확인까지 하나하나 신경써주는 코드라고 볼 수 있다.



## 반복문을 사용해서 일시키기

```java
int 영수_행주_깨끗함 = 100;
double 영수_윈덱스_리터 = 10.0;
while (!우리학교._101호.창문_깨끗함()) {
    if (영수_행주_깨끗함 <= 10)
        빨아오기(영수_행주_깨끗함);
    if (영수_윈덱스_리터 <= 1)
        리필해오기(영수_윈덱스_리터);

    우리학교._101호.창문_닦기(영수_행주_깨끗함, 영수_윈덱스_리터);
}

int 돌준_행주_깨끗함 = 100;
double 돌준_윈덱스_리터 = 10.0;
while (!우리학교._102호.창문_깨끗함()) {
    if (돌준_행주_깨끗함 <= 10)
        빨아오기(영수_행주_깨끗함);
    if (돌준_윈덱스_리터 <= 1)
        리필해오기(영수_윈덱스_리터);

    우리학교._101호.창문_닦기(영수_행주_깨끗함, 영수_윈덱스_리터);
}

double 철권_쓰레받기_채움 = 10.0;
while (!우리학교._101호.바닥_깨끗함()) {
    if (철권_쓰레받기_채움 >= 0.9)
        비우기(돌준_쓰레받기_채움);

    우리학교._101호.바닥_쓸기(철권_쓰레받기_채움);
}
```



- 코드를 해석하면

>영수에게 행주와 윈덱스리터를 주고 101호 창문이 깨끗해질때까지 행주를 빨고, 윈덱스 리필해가면서 101호 창문을 닦게한다.
>
>돌준에게 행주와 윈덱스리터를 주고 102호 창문이 깨끗해질때까지 행주를 빨고, 윈덱스 리필해가면서 102호 창문을 닦게한다.
>
>철권에게 쓰레받기를 주고 101호 바닥 깨끗해질 때까지 쓰레받기 비워가면서 101호 바닥을 쓸게 한다.



- 일을 시키기에는 편해졌지만 여전히 학생 한명한명에게 지시를 내리는 불편함은 여전하다.



## 함수(메소드) 사용하기

```java
public void 창문_닦기 (ClassRoom 담당_교실, int 행주_깨끗함, double 윈덱스_리터) {
    while (!담당_교실.창문_깨끗함()) {
        if (행주_깨끗함 <= 10) {
            빨아오기(행주_깨끗함);
        }
        if (윈덱스_리터 <= 1) {
            리필해오기(윈덱스_리터);
        }
        담당_교실.창문_닦기(행주_깨끗함, 윈덱스_리터);
    }
}

public void 바닥_쓸기 (ClassRoom 담당_교실, double 쓰레받기_채움) {
    while (!담당_교실.바닥_깨끗함()) {
        if (쓰레받기_채움 <= 10) {
            비우기(쓰레받기_채움);
        }
        담당_교실.바닥_쓸기(쓰레받기_채움);
    }
}

public void 칠판_닦기 (ClassRoom 담당_교실, double 지우개_깨끗함) {
    while (!담당_교실.칠판_깨끗함()) {
        if (지우개_깨끗함 <= 10) {
            털기(지우개_깨끗함);
        }
        담당_교실.칠판_닦기(지우개_깨끗함);
    }
}
```

- 코드를 해석하면

> 창문 닦기 방법을 공지한다
> 내용은 담당교실, 행주, 윈덱스를 받고
> 담당교실 창문이 깨끗해질때까지 행주를 빨고, 윈덱스 리필해가며
> 담당 교실 창문을 닦는다
>
> 바닥쓸기와 칠판닦기도 같은 방식으로 공지한다.

```java
int 영수_행주_깨끗함 = 100;
double 영수_윈덱스_리터 = 10.0;
창문_닦기(우리학교._101호, 영수_행주_깨끗함, 영수_윈덱스_리터);

int 돌준_행주_깨끗함 = 100;
double 돌준_윈덱스_리터 = 10.0;
창문_닦기(우리학교._102호, 돌준_행주_깨끗함, 돌준_윈덱스_리터);

double 철권_쓰레받기_채움 = 0;
바닥_쓸기(우리학교._101호, 철권_쓰레받기_채움);

int 변수_지우개_깨끗함 = 100;
칠판_닦기(우리학교._101호, 변수_지우개_깨끗함);
```

- 그리고 학생에게 청소를 시킨다.



::: tip

여기까지가 절차방식의 코드라고 볼 수 있다. 

지금까지는 작은 건물의 청소는 다음과 같은 방식으로 진행할 수 있지만

큰 건물을 청소를 한다면 코드도 길어지고 프로그래밍 하기 벅차다

:::



## 클래스 활용하기 (객체지향 요소 추가)

- 학생들에게 각각의 역할을 부여한다 (마치 게임의 직업과 비슷하게)
- 클래스를 이용하여 역할을 부여한다.

```java
public class 창문닦이 {

    private ClassRoom 담당_교실;
    private int 행주_깨끗함 = 100;
    private double 윈덱스_리터 = 10.0;

    public 창문닦이 (ClassRoom 교실) {
        담당_교실 = 교실;
    }

    public void 창문_닦기() {
        if (행주_깨끗함 <= 10) {
            빨아오기(행주_깨끗함);
        }
        if (윈덱스_리터 <= 1) {
            리필해오기(윈덱스_리터);
        }
        담당_교실.창문_닦기(행주_깨끗함, 윈덱스_리터);
    }
}
```

> 창문닦이는 깨끗한 행주와 윈덱스 10리터가 템으로 주어진다.
>
> 창문닦이가 되면 담당 교실이 하나씩 배정이 될거야
>
> 창문 닦기는 담당교실 창문 깨끗해 질 때까지 행주 빨고, 윈덱스 리필해가며 창문 닦으면된다.

```java
public class 바닥쓸이 {

    private ClassRoom 담당_교실;
    private double 쓰레받기_채움 = 0;

    public 바닥쓸이 (ClassRoom 교실) {
        담당_교실 = 교실;
    }

    public void 바닥_쓸기() {
        while (!담당_교실.바닥_깨끗함()) {
            if (쓰레받기_채움 <= 10) {
                비우기(쓰레받기_채움);
            }
            담당_교실.바닥_쓸기(쓰레받기_채움);
        }
    }
}

public class 칠판닦이 {

    private ClassRoom 담당_교실;
    private int 지우개_깨끗함 = 0;

    public 칠판닦이 (ClassRoom 교실) {
        담당_교실 = 교실;
    }

    public void 칠판_닦기() {
        while (!담당_교실.칠판_깨끗함()) {
            if (지우개_깨끗함 <= 10) {
                털기(지우개_깨끗함);
            }
            담당_교실.칠판_닦기(지우개_깨끗함);
        }
    }
}
```

- 위의 클래스(역할) 로 학생들에게 작업을 시켜준다

```java
창문닦이 영수 = new 창문닦이(우리학교._101호);
영수.창문_닦기();

창문닦이 혁순 = new 창문닦이(우리학교._102호);
혁순.창문_닦기();

창문닦이 달구 = new 창문닦이(우리학교._103호);
달구.창문_닦기();

바닥쓸이 철권 = new 바닥쓸이(우리학교._101호);
철권.창문_닦기();

바닥쓸이 철현 = new 바닥쓸이(우리학교._102호);
철현.창문_닦기();

칠판닦이 변수 = new 칠판닦이(우리학교._101호);
변수.창문_닦기();

// 한명씩 시키니까 입아프니까
// 거기 넷 칠판 닦어!

ArrayList<칠판닦이> 칠판닦이들 = new ArrayList<>();
칠판닦이들.add(new 칠판닦이(우리학교._102호));
칠판닦이들.add(new 칠판닦이(우리학교._103호));
칠판닦이들.add(new 칠판닦이(우리학교._104호));
칠판닦이들.add(new 칠판닦이(우리학교._105호));

for (칠판닦이 닦이 : 칠판닦이들) {
    닦이.칠판_닦기();
}
```

- 아무 역할이 없는 학생에게 클래스로 정의한 아이템과 동작들이 주어져서 창문닦이, 바닥쓸이, 칠판닦이 들이 생성되었다. 
- 이렇게, 데이터와 기능이 클래스로 **캡슐화** 된 컴퓨터 자원의 묶음을 **객체**라고 한다!!

::: tip

객체지향 전에는 아무런 데이터도 없는 컴퓨터 자원들을 가져다가 하나하나 명령어를 줘 가면서 코드를 짜야했다. 

하지만 객체지향을 사용해서 클래스라는 모양틀을 만들고 모양과 용도가 뚜렷한 객체가 만들어진다.

마치 이전에는 흙을 빚어서 집을 지었다면 객체지향에서는 벽돌 틀을 만들어 모양과 용도가 뚜렷한 벽돌들이 만들어 지는 것이다.

:::



### 은닉성

```java
public class 창문닦이 {

    private ClassRoom 담당_교실;
    private int 행주_깨끗함 = 100;
    private double 윈덱스_리터 = 10.0;

    public 창문닦이 (ClassRoom 교실) {
        담당_교실 = 교실;
    }

    public void 창문_닦기() {
        if (행주_깨끗함 <= 10) {
            빨아오기(행주_깨끗함);
        }
        if (윈덱스_리터 <= 1) {
            리필해오기(윈덱스_리터);
        }
        담당_교실.창문_닦기(행주_깨끗함, 윈덱스_리터);
    }
}
```

> 선생님, 행주(private) 나 윈덱스(private) 는 저만의 운용 방식이 있으니까 번거롭게 관여하지 마세요
>
> 창문닦기(public) 동작이 있으니까 이 명령어로 지시를 내려주시면 행주나 윈덱스는 제가 운용하도록 하겠슴다

- 내부 구조는 private 로 감추어 놓고 외부에서 조작할 수 있는 명령어만 public으로 공개해놓는 방식이다. 
- 내부 구조를 살펴볼 필요 없이 제공되는 기능들을 그대로 사용할 수 있는 것이다.
- 마치 TV 의 내부구조를 몰라도 리모콘으로 TV를 시청할 수 있는 것과 같다.



## 인터페이스

- 한 명령어로 모두에게 일 시키기

```
public interface 청소담당 {
    public void 청소 ();
    public void 교실_이동 (ClassRoom 교실);
}
```

- 인터페이스에서는 메소드의 내용이 무엇인지 정의하지 않는다.
- 창문닦이_v2를 보자

```java
public class 창문닦이_v2 implements 청소담당 {
        
    private ClassRoom 담당_교실;
    private int 행주_깨끗함 = 100;
    private double 윈덱스_리터 = 10.0;

	public 창문닦이_v2 (ClassRoom 교실) {
        담당_교실 = 교실;
    }
    
    public void 창문_닦기() {
        while (!담당_교실.창문_깨끗함()) {
            if (행주_깨끗함 <= 10)
                빨아오기(행주_깨끗함);
            if (윈덱스_리터 <= 1)
                리필해오기(윈덱스_리터);
            담당_교실.창문_닦기(행주_깨끗함, 윈덱스_리터);
        }
    }
    
    @Override
    public void 청소() {
        창문_닦기();
    }
    @Override
    public void 교실_이동(ClassRoom 교실) {
        담당_교실 = 교실;
    }
}
```

- 창문닦이_v2는 청소담당을 상속받으면 필수로 '청소', '교실이동' 메소드를 수행한다.

```java
public class 바닥쓸이_v2 implements 청소담당 {

    private ClassRoom 담당_교실;
    private double 쓰레받기_채움 = 0;

    public 바닥쓸이_v2 (ClassRoom 교실) {
        담당_교실 = 교실;
    }

    public void 바닥_쓸기() {
        while (!담당_교실.바닥_깨끗함()) {
            if (쓰레받기_채움 <= 10)
                비우기(쓰레받기_채움);
            담당_교실.바닥_쓸기(쓰레받기_채움);
        }
    }

    @Override
    public void 청소() {
        바닥_쓸기();
    }
    @Override
    public void 교실_이동(ClassRoom 교실) {
        담당_교실 = 교실;
    }

}

public class 칠판닦이_v2 implements 청소담당 {

    private ClassRoom 담당_교실;
    private int 지우개_깨끗함 = 0;

    public 칠판닦이_v2 (ClassRoom 교실) {
    	담당_교실 = 교실;
    }

    public void 칠판_닦기() {
        while (!담당_교실.칠판_깨끗함()) {
            if (지우개_깨끗함 <= 10) {
                털기(지우개_깨끗함);
        }
            담당_교실.칠판_닦기(지우개_깨끗함);
        }
    }

    @Override
    public void 청소() {
    	칠판_닦기();
    }
    @Override
    public void 교실_이동(ClassRoom 교실) {
    	담당_교실 = 교실;
    }
}
```

- 다른 청소역할도 동일한 방식으로 작성할 수 있다.

```java
창문닦이_v2 영수 = new 창문닦이_v2(우리학교._101호);
바닥쓸이_v2 철권 = new 바닥쓸이_v2(우리학교._101호);
칠판닦이_v2 변수 = new 칠판닦이_v2(우리학교._101호);

영수.청소(); 철권.청소(); 변수.청소();

ArrayList<청소담당> 청소담당들 = new ArrayList<>();

청소담당들.add(new 칠판닦이_v2(우리학교._102호));
청소담당들.add(new 칠판닦이_v2(우리학교._103호));
청소담당들.add(new 칠판닦이_v2(우리학교._104호));
청소담당들.add(new 칠판닦이_v2(우리학교._105호));

청소담당들.add(new 바닥쓸이_v2(우리학교._102호));
청소담당들.add(new 바닥쓸이_v2(우리학교._103호));
청소담당들.add(new 바닥쓸이_v2(우리학교._104호));
청소담당들.add(new 바닥쓸이_v2(우리학교._105호));

청소담당들.add(new 칠판닦이_v2(우리학교._102호));
청소담당들.add(new 칠판닦이_v2(우리학교._103호));
청소담당들.add(new 칠판닦이_v2(우리학교._104호));
청소담당들.add(new 칠판닦이_v2(우리학교._105호));

for (청소담당 담당 : 청소담당들) {
	담당.청소();
}
```

- 이처럼 각 학생들에게 클래스를 부여하여 청소를 시킬 수 있게 되었다. 



## 클래스로 클래스 만들기

팀 단위로 청소하기

```java
    public class 교실청소팀 {
        protected ClassRoom 담당_교실;
        
        private 창문닦이_v2 창문닦이_1, 창문닦이_2;
        private 바닥쓸이_v2 바닥쓸이_1, 바닥쓸이_2, 바닥쓸이_3;
        private 칠판닦이_v2 칠판닦이_1;
        
        private 청소담당[] 팀원들 = {
                창문닦이_1, 창문닦이_2,
                바닥쓸이_1, 바닥쓸이_2, 바닥쓸이_3,
                칠판닦이_1
        };
        
        public 교실청소팀 (ClassRoom 교실) {
            담당_교실 = 교실;
            창문닦이_1 = new 창문닦이_v2(교실); 창문닦이_2 = new 창문닦이_v2(교실);
            바닥쓸이_1 = new 바닥쓸이_v2(교실); 바닥쓸이_2 = new 바닥쓸이_v2(교실);
            바닥쓸이_3 = new 바닥쓸이_v2(교실); 칠판닦이_1 = new 칠판닦이_v2(교실);
        }
        
        public void 교실청소() {
            for (청소담당 팀원 : 팀원들) {
                팀원.청소();
            }
        }
        
        public boolean 청소완료 () {
            return 담당_교실.창문_깨끗함() && 담당_교실.바닥_깨끗함() && 담당_교실.칠판_깨끗함();
        }
        
        public void 교실_이동 (ClassRoom 교실) {
            for (청소담당 팀원 : 팀원들) {
                팀원.교실_이동(교실);
            }
        }
    }
```

- 이전에 정의해놓은 클래스를 구성하여 교실청소팀이라는 새로운 클래스를 생성한다.

```java
	교실청소팀 _1팀 = new 교실청소팀(우리학교._101호);
    _1팀.교실청소();
    
    ArrayList<교실청소팀> 교실청소팀들 = new ArrayList<>();
    교실청소팀들.add(new 교실청소팀(우리학교._102호));
    교실청소팀들.add(new 교실청소팀(우리학교._103호));
    교실청소팀들.add(new 교실청소팀(우리학교._104호));
    교실청소팀들.add(new 교실청소팀(우리학교._105호));
    for (교실청소팀 팀 : 교실청소팀들) {
        팀.교실청소();
    }
    
    if (_1팀.청소완료()) {
        _1팀.교실_이동(우리학교._201호);
        _1팀.교실청소();
    }
```

- 이렇게 학생들을 교실단위로 청소를 시킬 수 있게 되었다.





## 상속

- 다음은 교실청소팀으로만 으로는 청소할 수 없는 구역을 청소하기 위한 클래스를 생성해본다.
- 물론 새로 만들 수 있지만 청소업무는 공통부분이 많기에 상속을 통해서 클래스를 생성한다. 
- 따라서 교실청소팀(부모클래스) 으로 과학실청소팀(자식클래스) 를 만들 수 있다. 
- 다음은 교실청소팀을 상속받은 과학실청소팀_v2 이다. 

```
	public class 과학실청소팀_v2 extends 교실청소팀 {

        // 새로추가된 도구
        실험기구닦이 실험기구닦이_1;

        public 과학청소팀_v2 (ClassRoom 교실) {
            super(교실);
            실험기구닦이_1 = new 실험기구닦이(교실);
        }

        @Override
        public void 교실청소 () {
            super.교실청소();
            실험기구닦이_1.청소();
        }

        @Override
        public boolean 청소완료() {
            return super.청소완료() && 담당_교실.실험기구_깨끗함();
        }

        @Override
        public void 교실_이동 (ClassRoom 교실) {
            super.교실_이동(교실);
            실험기구닦이_1.교실_이동(교실);
        }
    }
```

- 상위 클래스 (교실청소팀) 에서 수행하는 작업 이외 추가적인 변수(실험가구닦이)나 작업 들은 각 범위 안에 추가한다. 
- 이것을 동물에 분류하면 상위클래스는 포유류, 하위클래스는 개 고양이 말 이라고 할 수 있으며 이는 하위클래스에서 구체적이게 되었다는 이야기 이다.

